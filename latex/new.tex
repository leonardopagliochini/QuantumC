\documentclass[conference]{IEEEtran}
\IEEEoverridecommandlockouts
\usepackage{cite}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{algorithmic}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{xcolor}
\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}

\begin{document}

\title{Se te sapesse dicere, 'o core mio quant'è ca t'ama\\
% \thanks{Optional: acknowledge funding or collaboration here.}
}

\author{
\IEEEauthorblockN{Francesco Rosnati}
\IEEEauthorblockA{
\textit{MSc Candidate in High Performance Engineering} \\
\textit{Politecnico di Milano} \\
Milan, Italy \\
francesco.rosnati@mail.polimi.it}
\and
\IEEEauthorblockN{Leonardo Ignazio Pagliochini}
\IEEEauthorblockA{
\textit{MSc Candidate in High Performance Engineering} \\
\textit{Politecnico di Milano} \\
Milan, Italy \\
leonardoignazio.pagliochini@mail.polimi.it}
}

\maketitle

\begin{abstract}
% TODO: Inserire abstract
\end{abstract}

\begin{IEEEkeywords}
quantum computing, compiler design, intermediate representation, performance evaluation
\end{IEEEkeywords}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% INTRODUCTION
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Introduction}
% TODO: Scrivere introduzione

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% BACKGROUND
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Background}

\subsection{Motivation for Quantum Computing}

Quantum computing is a new paradigm that promises to solve certain classes of problems more efficiently than classical computing, by exploiting quantum phenomena such as superposition, interference, and entanglement. %~\cite{nielsen_chuang, ladd2010quantum}
As Ladd et al. emphasize, quantum computers are not simply faster versions of classical computers, but rather devices that manipulate information in fundamentally different ways by controlling coherent quantum wavefunctions. %~\cite{ladd2010quantum}

Although landmark algorithms such as Grover’s search and Shor’s factoring have demonstrated polynomial and exponential speedups, practical quantum computation faces major challenges. These include high error rates, limited coherence times, and low qubit counts, which require careful management of quantum resources. %~\cite{ladd2010quantum}

\subsection{Resource Constraints in Quantum Hardware}

As quantum hardware matures, the limited number of qubits, short coherence times, and high gate error rates remain dominant challenges, especially for noisy intermediate-scale quantum (NISQ) devices. These limitations demand compilation strategies that emphasize resource-efficiency: minimizing qubit usage, gate depth, and ancilla requirements. %~\cite{ladd2010quantum}

\subsection{Reversible Compilation from Classical Code}

One way to approach these constraints is to avoid hybrid quantum-classical schemes and instead compile classical logic directly into reversible quantum circuits. Zulehner and Wille propose synthesizing quantum circuits from classical control dataflow graphs, enabling classical control logic to be embedded within quantum programs. %~\cite{zulehner2023date}
This is particularly promising in view of future quantum architectures that aim for tightly integrated control and data planes.

\subsection{Integer Representation and Arithmetic}

Transforming classical programs into quantum logic circuits requires reversible integer computation. A common approach is to use two's complement binary encoding, which allows arithmetic operations like addition and subtraction to be realized using reversible gates. This encoding is both compact and generalizable. As Takahashi surveys, this representation supports constructions such as ripple-carry adders and QFT-based adders with different trade-offs between depth and ancilla usage. %~\cite{gazzola2025mlir}

Moreover, quantum circuits can represent integers using any desired bit-width, allowing the programmer to balance precision with hardware cost. This is especially important when analyzing gate count and qubit usage under resource constraints. %~\cite{ying2022dataflow}

In certain cases, operations such as addition can be implemented using the quantum Fourier transform (QFT), which permits in-place arithmetic with no ancillary qubits. However, this comes at the cost of longer circuit depth and high phase accuracy. %~\cite{gazzola2025mlir}

\subsection{Intermediate Representations for Quantum Compilers}

To structure such compilation pipelines, intermediate representations (IRs) have been proposed to bridge high-level classical code and backend quantum assembly. These IRs serve as abstraction layers that support modular passes (e.g., optimizations, scheduling, resource estimation) while remaining independent of backend technologies like QASM or Quil. QIRO and other IRs exploit Static Single Assignment (SSA) form to enable dataflow optimizations, which are vital in the quantum setting where state overwriting is not trivial. %~\cite{hietala2020qiro}

The IR proposed by Gazzola et al. extends MLIR with quantum operations and supports reversible gate conversion directly from classical logic. Unlike previous work that starts from quantum DSLs, their approach generates quantum IR from a hardware description language (SystemVerilog), enforcing reversibility and optimizing resource usage via dedicated transformation passes. %~\cite{gazzola2025quantumir}

\vspace{1em}

This background frames our work: a system that compiles imperative classical code into reversible quantum circuits via a structured intermediate representation. The design prioritizes backend independence, arithmetic-aware IR structure, and resource optimization, including  use of QFT-based computation.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% RELATED WORK
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Related Work}

Several compiler infrastructures have been developed to optimize quantum programs across different levels of abstraction. These projects differ in their source language support, intermediate representations, and backend code generation strategies.

\subsection{Quantum Intermediate Representations and Classical Logic}

QIRO introduces an SSA-based quantum IR for optimizing hand-written quantum programs. It applies static analysis techniques such as dependency tracking and dead code elimination. However, QIRO assumes quantum-centric inputs and does not support the compilation of classical imperative languages or arithmetic logic.

Zulehner and Wille propose a high-level synthesis (HLS) method that converts classical control dataflow graphs into reversible circuits. Their approach allows embedding classical control into quantum circuits, but operates at a lower abstraction level, using reversible gate libraries without an IR or typed constructs like quantum registers. Moreover, their design does not support higher-order arithmetic primitives or QFT-based arithmetic.

The QuantumIR project compiles SystemVerilog into reversible gate-level circuits. While similar in pipeline structure, it transforms bit-level combinatorial logic and does not support typed integer arithmetic or control structures. In contrast, our IR models quantum variables as typed entities and supports structured arithmetic and control flow transformations.

\subsection{MLIR-based Approaches and Optimization Frameworks}

Gazzola and Carugati propose an MLIR dialect that introduces quantum operations for reversible logic extracted from classical descriptions. Their system emphasizes classical-to-quantum conversion and reversible arithmetic, but does not start from general-purpose imperative code. Our work builds on this by introducing typed abstractions, scoped registers, and a higher-level frontend based on C.

Ying et al. focus on optimizing quantum-native IRs through SSA-based static analysis. Their transformations, including wire reuse and entanglement analysis, are powerful but assume pre-existing quantum logic and do not integrate with classical code parsing or arithmetic synthesis.

\subsection{Positioning Our Work}

While previous works address quantum IR design, reversible logic synthesis, or dataflow optimization, none bridge imperative classical code with typed quantum arithmetic via a backend-agnostic IR. Our system introduces a higher-level MLIR dialect that supports resource-aware design, typed quantum registers, QFT-backed arithmetic, and modular backend lowering—filling a gap between structural synthesis and high-level quantum programming.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% METHODS
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Methods}

\subsection{Structure}
% TODO: Architettura generale del sistema

\subsection{Intermediate Representation}
% TODO: Descrizione IR, design, semantica

\subsection{Quantum Operations and Circuits}
% TODO: Modellazione di operazioni quantistiche, flusso di controllo, misure

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% RESULTS
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Results}

\subsection{Time Benchmark}
% TODO: Benchmark di performance classica

\subsection{Quantum Complexity}
% TODO: Analisi di profondità, larghezza e gate count

\subsection{Transpiling}
% TODO: Risultati del transpile verso circuiti reali/backends

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% DISCUSSION AND CONCLUSION
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Discussion}
% TODO: Discussione dei risultati, confronto, limiti

\section{Conclusion}
% TODO: Conclusioni e futuri sviluppi

\bibliographystyle{IEEEtran}
\bibliography{references}

\end{document}
