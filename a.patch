diff --git a/quantum_translate.py b/quantum_translate.py
index 3916cc0fb602d2ce45322fe515e3050d788ff3f8..b255c28d1a6967a8ac91794453038590654965f2 100644
--- a/quantum_translate.py
+++ b/quantum_translate.py
@@ -68,53 +68,62 @@ class QuantumTranslator:
 
         # The original module that will be walked and rewritten.
         self.module = module
 
         # Placeholder for the translated module once ``translate`` is called.
         self.q_module: ModuleOp | None = None
 
         # ``next_reg`` stores the number of the next free quantum register.
         # Registers are identified by an integer and are allocated sequentially.
         self.next_reg = 0
 
         # Mapping from SSA values in the original module to ``ValueInfo``
         # records.  These records describe which register currently contains the
         # value and how it can be recomputed if needed.
         self.val_info: Dict[SSAValue, ValueInfo] = {}
 
         # Track, for each register, which version of the value it currently
         # holds.  This allows the translator to detect when a cached value has
         # been overwritten and needs recomputation.
         self.reg_version: Dict[int, int] = {}
 
         # Map each register identifier to the most recent SSA value representing
         # its contents in the quantum module being built.
         self.reg_ssa: Dict[int, SSAValue] = {}
 
+        # Track which original SSA value currently occupies each register. This
+        # is required so that ``recompute`` can determine if overwriting a
+        # register would destroy a value that is still needed.
+        self.reg_owner: Dict[int, SSAValue] = {}
+
         # Number of remaining uses for every SSA value in the original module.
         self.use_count: Dict[SSAValue, int] = {}
 
+        # Remaining use counts updated while translating a function. Populated
+        # in :meth:`translate_func` and consulted during recomputation.
+        self.remaining: Dict[SSAValue, int] | None = None
+
         # Cache used by ``compute_cost`` to memoize recomputation costs.
         self.cost_cache: Dict[SSAValue, int] = {}
 
     # ------------------------------------------------------------------
     def translate(self) -> ModuleOp:
         """Translate the entire module to the quantum dialect."""
 
         # First compute how many times each SSA value is used.  This information
         # is needed later when deciding whether we can overwrite a register or
         # if we must keep its original value alive.
         self.compute_use_counts()
 
         # Create a new, empty module that will hold the translated functions.
         self.q_module = ModuleOp([])
 
         # Translate each function one by one and append the resulting quantum
         # function to the new module.
         for func in self.module.ops:
             q_func = self.translate_func(func)
             self.q_module.body.blocks[0].add_op(q_func)
 
         # The new module is now populated with quantum dialect operations.
         return self.q_module
 
     # ------------------------------------------------------------------
diff --git a/quantum_translate.py b/quantum_translate.py
index 3916cc0fb602d2ce45322fe515e3050d788ff3f8..b255c28d1a6967a8ac91794453038590654965f2 100644
--- a/quantum_translate.py
+++ b/quantum_translate.py
@@ -196,122 +205,128 @@ class QuantumTranslator:
         """Ensure ``val`` is materialized and return its SSA value."""
 
         # ``val_info`` tells us which register currently stores ``val`` and
         # which version of the value should be present there.
         info = self.val_info[val]
         reg = info.reg
 
         # If the register has been updated since ``info`` was recorded we must
         # recompute the value so that the register again holds the desired
         # version.
         if self.reg_version[reg] != info.version:
             self.recompute(val)
             reg = info.reg
 
         # Return the SSA value associated with the current contents of the
         # register.
         return self.reg_ssa[reg]
 
     # ------------------------------------------------------------------
     def recompute(self, val: SSAValue):
         """Recompute ``val`` based on the expression stored in ``val_info``."""
 
         info = self.val_info[val]
         expr = info.expr
 
+        # Determine whether overwriting ``info.reg`` would clobber a value that
+        # still has remaining uses.  If so we allocate a fresh register for the
+        # recomputed value instead.
+        reg = info.reg
+        current = self.reg_owner.get(reg)
+        need_new = False
+        if current is not None and current is not val and self.remaining is not None:
+            if self.remaining.get(current, 0) > 0:
+                need_new = True
+        version = self.reg_version[reg] + 1
+        if need_new:
+            reg = self.allocate_reg()
+
         # ``expr`` is a tuple describing how ``val`` was originally produced.
         # The first element selects the kind of expression.
         if expr[0] == "const":
-            # The value was produced by a constant operation.
+            # The value was produced by a constant operation. Constants always
+            # materialize into a fresh register since their original storage may
+            # have been clobbered.
             value = expr[1]
-            reg = info.reg
-            version = self.reg_version[reg] + 1
-
-            # Allocate a fresh register so that we do not overwrite the
-            # previous value. Quantum registers cannot be reset in place without
-            # destroying information.
             reg = self.allocate_reg()
 
             # Emit the initialization of the new register with the constant
             # value.
             op = QuantumInitOp(value)
             self.current_block.add_op(op)
 
             # Track the new version and SSA value for the register.
             op.results[0].name_hint = f"q{reg}_{version}"
             self.reg_version[reg] = version
             self.reg_ssa[reg] = op.results[0]
+            self.reg_owner[reg] = val
 
             # Update the stored ``ValueInfo`` so future uses know where the
             # value lives.
             info.version = version
             info.reg = reg
 
         elif expr[0] == "binary":
             # ``val`` was produced by a binary operation with two operands.
             opcode, lhs, rhs, target = expr[1]
             q_lhs = self.emit_value(lhs)
             q_rhs = self.emit_value(rhs)
 
             # Determine which register will hold the result.  If ``target`` is
             # ``rhs`` we swap the operands because the operation will update the
             # register corresponding to ``rhs``.
             if target is rhs:
                 first = q_rhs
                 second = q_lhs
-                reg = self.val_info[rhs].reg
             else:
                 first = q_lhs
                 second = q_rhs
-                reg = self.val_info[lhs].reg
 
             # Emit the appropriate quantum binary operation.
             op = self.create_binary_op(opcode, first, second)
             self.current_block.add_op(op)
 
-            # Update bookkeeping for the target register.
-            version = self.reg_version[reg] + 1
             op.results[0].name_hint = f"q{reg}_{version}"
             self.reg_version[reg] = version
             self.reg_ssa[reg] = op.results[0]
+            self.reg_owner[reg] = val
             info.version = version
+            info.reg = reg
 
         elif expr[0] == "binaryimm":
             # ``val`` came from a binary operation with an immediate operand.
             opcode, lhs, imm = expr[1]
             q_lhs = self.emit_value(lhs)
-            reg = self.val_info[lhs].reg
             op = self.create_binary_imm_op(opcode, q_lhs, imm)
             self.current_block.add_op(op)
 
-            # As above, bump the register version and remember the result SSA
-            # value.
-            version = self.reg_version[reg] + 1
             op.results[0].name_hint = f"q{reg}_{version}"
             self.reg_version[reg] = version
             self.reg_ssa[reg] = op.results[0]
+            self.reg_owner[reg] = val
             info.version = version
+            info.reg = reg
 
         else:
             raise NotImplementedError
 
     # ------------------------------------------------------------------
     def create_binary_op(self, opcode: str, lhs: SSAValue, rhs: SSAValue) -> Operation:
         """Emit a binary quantum op for ``opcode``."""
 
         # Map the textual opcode to the corresponding quantum operation class.
         if opcode == "add":
             return QAddiOp(lhs, rhs)
         if opcode == "sub":
             return QSubiOp(lhs, rhs)
         if opcode == "mul":
             return QMuliOp(lhs, rhs)
         if opcode == "div":
             return QDivSOp(lhs, rhs)
         raise NotImplementedError(opcode)
 
     def create_binary_imm_op(self, opcode: str, lhs: SSAValue, imm: int) -> Operation:
         """Emit an immediate binary op for ``opcode``."""
 
         # Similar to ``create_binary_op`` but one operand is a Python integer.
         if opcode == "add":
             return QAddiImmOp(lhs, imm)
diff --git a/quantum_translate.py b/quantum_translate.py
index 3916cc0fb602d2ce45322fe515e3050d788ff3f8..b255c28d1a6967a8ac91794453038590654965f2 100644
--- a/quantum_translate.py
+++ b/quantum_translate.py
@@ -323,128 +338,131 @@ class QuantumTranslator:
             return QDivSImmOp(lhs, imm)
         raise NotImplementedError(opcode)
 
     # ------------------------------------------------------------------
     def translate_func(self, func: FuncOp) -> FuncOp:
         """Translate a single function to the quantum dialect."""
 
         # We only handle single-block functions. ``block`` is the list of
         # arithmetic operations that will be translated.
         block = func.body.blocks[0]
 
         # ``current_block`` accumulates the newly created quantum operations.
         self.current_block = Block()
 
         # Clear the cost cache since costs depend on the current function only.
         self.cost_cache.clear()
 
         # Pre-compute the cost for each produced value.  This information is
         # later used to choose whether to recompute an operand or to store it.
         for op in block.ops:
             for res in op.results:
                 self.compute_cost(res)
 
         # ``remaining`` tracks how many uses of each SSA value remain while we
         # traverse the block.  Start with the global use counts.
-        remaining = {val: len(val.uses) for val in self.use_count}
+        self.remaining = {val: len(val.uses) for val in self.use_count}
 
         # Translate each operation in order.
         for op in block.ops:
             if isinstance(op, ConstantOp):
                 # Constants simply allocate a new register and initialize it.
                 reg = self.allocate_reg()
                 init_op = QuantumInitOp(op.value.value.data)
                 self.current_block.add_op(init_op)
                 init_op.results[0].name_hint = f"q{reg}_0"
                 self.val_info[op.results[0]] = ValueInfo(reg, 0, ("const", op.value.value.data))
                 self.reg_ssa[reg] = init_op.results[0]
+                self.reg_owner[reg] = op.results[0]
 
             elif isinstance(op, (AddiOp, SubiOp, MuliOp, DivSIOp)):
                 # Binary arithmetic operation with two SSA operands.
                 lhs, rhs = op.operands
 
                 # Compute remaining use counts for operands after this
                 # operation executes.
-                left_count = remaining[lhs] - 1
-                right_count = remaining[rhs] - 1
-                remaining[lhs] -= 1
-                remaining[rhs] -= 1
+                left_count = self.remaining[lhs] - 1
+                right_count = self.remaining[rhs] - 1
+                self.remaining[lhs] -= 1
+                self.remaining[rhs] -= 1
 
                 # Materialize the current values of the operands.
                 q_lhs = self.emit_value(lhs)
                 q_rhs = self.emit_value(rhs)
 
                 # Determine the opcode string for convenience.
                 opcode = {
                     AddiOp: "add",
                     SubiOp: "sub",
                     MuliOp: "mul",
                     DivSIOp: "div",
                 }[type(op)]
 
                 # ``add`` and ``mul`` are commutative.  When possible we update
                 # the operand that will not be used again to avoid allocating a
                 # new register.
                 comm = opcode in ("add", "mul")
                 if comm:
                     if left_count > 0 and right_count == 0:
                         first, second, target = q_rhs, q_lhs, rhs
                     elif right_count > 0 and left_count == 0:
                         first, second, target = q_lhs, q_rhs, lhs
                     else:
                         if self.compute_cost(lhs) <= self.compute_cost(rhs):
                             first, second, target = q_lhs, q_rhs, lhs
                         else:
                             first, second, target = q_rhs, q_lhs, rhs
                 else:
                     first, second, target = q_lhs, q_rhs, lhs
 
                 # Emit the quantum binary operation and update bookkeeping for
                 # the target register.
                 new_op = self.create_binary_op(opcode, first, second)
                 self.current_block.add_op(new_op)
                 reg = self.val_info[target].reg
                 version = self.reg_version[reg] + 1
                 new_op.results[0].name_hint = f"q{reg}_{version}"
                 self.reg_version[reg] = version
                 self.reg_ssa[reg] = new_op.results[0]
+                self.reg_owner[reg] = op.results[0]
                 self.val_info[op.results[0]] = ValueInfo(reg, version, ("binary", (opcode, lhs, rhs, target)))
 
             elif op.name in ("iarith.addi_imm", "iarith.subi_imm", "iarith.muli_imm", "iarith.divsi_imm"):
                 # Binary operation where one operand is an immediate integer.
                 (lhs,) = op.operands
                 imm = int(op.imm.value.data)
-                remaining[lhs] -= 1
+                self.remaining[lhs] -= 1
                 q_lhs = self.emit_value(lhs)
                 opcode = {
                     "iarith.addi_imm": "add",
                     "iarith.subi_imm": "sub",
                     "iarith.muli_imm": "mul",
                     "iarith.divsi_imm": "div",
                 }[op.name]
                 new_op = self.create_binary_imm_op(opcode, q_lhs, imm)
                 self.current_block.add_op(new_op)
                 reg = self.val_info[lhs].reg
                 version = self.reg_version[reg] + 1
                 new_op.results[0].name_hint = f"q{reg}_{version}"
                 self.reg_version[reg] = version
                 self.reg_ssa[reg] = new_op.results[0]
+                self.reg_owner[reg] = op.results[0]
                 self.val_info[op.results[0]] = ValueInfo(reg, version, ("binaryimm", (opcode, lhs, imm)))
 
             elif isinstance(op, ReturnOp):
                 # Return statements are forwarded directly after materializing
                 # the returned value.
                 if op.operands:
                     q_val = self.emit_value(op.operands[0])
                     ret = ReturnOp(q_val)
                 else:
                     ret = ReturnOp([])
                 self.current_block.add_op(ret)
 
             else:
                 # Any other operation is currently unsupported.
                 raise NotImplementedError(f"Unsupported op {op.name}")
 
         # Construct the function with the same signature as the original but
         # containing the newly built block of quantum operations.
         func_type = ([i32] * len(func.function_type.inputs.data), [i32])
         return FuncOp(func.sym_name.data, func_type, Region([self.current_block]))
