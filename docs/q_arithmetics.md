# Quantum Arithmetic Helpers

This document describes `q_arithmetics.py`, which implements the low‑level
quantum arithmetic routines used by the pipeline described in the main
[README](../README.md).  The routines are written using Qiskit and operate on
quantum registers representing integers in two's complement form.  They provide
the building blocks used by `circuit_pipeline.py` to interpret the quantum
MLIR generated by the compiler.

## Overview
The module exposes a set of routines that manipulate quantum registers
representing signed integers.  All integers use a configurable number of
qubits (`NUMBER_OF_BITS`), defaulting to four.  Values are encoded in
two's complement and most operations either modify registers in place
or allocate a new register for the result.
## Register Management and Encoding
* `set_number_of_bits(n)` sets the global register width used for every
  operation.  This must be called before building a circuit.
* `int_to_twos_complement(value)` converts a Python integer into a list of
  bits representing the number in two's complement with the configured width.
* `initialize_variable(qc, value, name=None)` creates a fresh quantum register
  of that width, adds it to the given circuit and initializes it to the desired
  classical integer by applying `X` gates where needed.
* `unique_reg_name(existing, base)` is a small helper used internally to avoid
  collisions when creating new registers.
## Addition and Subtraction
Quantum addition is implemented following the standard Quantum Fourier
Transform (QFT) based approach.  `add(qc, a, b)` allocates an output register,
performs a QFT on it and then adds each input via controlled phase rotations
before applying the inverse transform.  `add_in_place(qc, a, b)` performs the
same computation but writes the sum back into the first operand.

`addi(qc, a, value)` and `addi_in_place(qc, a, value)` add a classical
immediate using phase rotations derived from the two's complement encoding of
`value`.

Subtraction uses the two's complement identity `a - b = a + (-b)` via the helper
`invert` which flips all bits and adds one.  The routines `sub` and `subi`
mirror the behaviour of `add`/`addi` but compute differences.
## Multiplication and Division
`mul(qc, a, b)` multiplies two registers of equal width.  The routine
implements the schoolbook method in the Fourier domain using
controlled‑controlled phase rotations.  The result is truncated to the
register size (i.e. multiplication is performed modulo $2^n$).

`muli(qc, a, c)` multiplies a register by a classical integer `c` by
programming the phase rotations accordingly.  Negative constants are
handled by computing the absolute value and applying `invert` when the
computation finishes.

Division is provided by `divu` and `div` for unsigned and signed inputs,
respectively.  Both use a restoring division algorithm implemented on
qubits.  `div` converts the operands to sign–magnitude representation
before calling `divu` and later restores two's complement form.  Variants
`divui` and `divi` accept a classical divisor.
## Comparison and Logic
Several predicates are implemented by building on the arithmetic
operations:

* `equal`, `not_equal`
* `less_than`, `greater_than`
* `less_equal`, `greater_equal`

The comparison logic pads operands to the same width, performs the
necessary arithmetic and extracts the sign bit of the difference.

Logical operators on single qubits are provided as `logical_and` and
`logical_or`.  These allocate an ancilla qubit initialized to $|0\rangle$
(or $|1\rangle$ for OR) and use `ccx` based constructions.
## Sign Manipulation
The helpers `twos_to_sign_magnitude` and `sign_magnitude_to_twos` convert
between the two representations.  They allocate a qubit storing the sign
bit and apply a controlled inversion to implement the transformation.
`abs_val` is a thin wrapper around these routines to produce the absolute
value of a register in place.
## Measurement and Simulation
`measure` attaches a classical register to a quantum register and measures
it.  `measure_single` is a convenience wrapper for individual qubits.
The `simulate` helper runs the circuit either on `AerSimulator` (if
available) or on Qiskit's basic simulator and prints the measured result
interpreted as two's complement integers.
## Internal Helpers
For completeness the file also exposes several functions prefixed with an
underscore.  They implement primitive controlled operations used by the
higher level routines above (`_sub_in_place`, `_controlled_add_in_place`,
`_controlled_invert_in_place`, `_controlled_addi_in_place`).  These are not
normally called directly outside of the module but are essential for
constructing the controlled versions found in `q_arithmetics_controlled.py`.
## Supported C Operations
The compiler currently handles a small integer‑only subset of C.  Expressions
are built from constants, variables and the binary operators `+`, `-`, `*`
and `/`.  Comparisons use `==`, `!=`, `<`, `<=`, `>` and `>=`.  The test
programs in `c_code/` mostly consist of straight‑line arithmetic or simple
loops; control flow is lowered to a sequence of conditional and branch
operations in the quantum dialect.  Every arithmetic operator maps to one
of the primitives described above.
## Role in the Pipeline
During circuit generation (`circuit_pipeline.py`), each quantum dialect
operation is interpreted by invoking the corresponding helper from this
module.  Registers are allocated lazily and are never copied: if a value is
needed again after being overwritten, it is recomputed using the expression
metadata tracked by the translator.  This approach keeps the circuit size
manageable while allowing in‑place updates when safe.