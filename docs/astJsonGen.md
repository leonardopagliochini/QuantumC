# astJsonGen.py Documentation

`astJsonGen.py` is a helper utility that converts the C test programs shipped
with this repository into JSON based abstract syntax trees (ASTs).  The JSON
format is generated by **Clang** using its `-ast-dump=json` option.  Other
components of the project parse these JSON files to drive the rest of the
compiler pipeline.

The script scans a directory containing C sources (by default the `c_code`
folder) and emits a corresponding JSON file for every `.c` file.  The output is
placed in a sibling `json_out` directory.  Each invocation is independent, so
re-running the script updates all ASTs and ensures they remain in sync with the
sources.

## Usage

```bash
python astJsonGen.py              # process files in ./c_code
python astJsonGen.py some/dir     # process files in a custom directory
```

A typical run will generate a series of `<name>.json` files inside the
`json_out` directory.  These files are then consumed by `pipeline.py` and other
modules that lower the AST to MLIR and subsequently to the custom quantum
dialect used in this project.

## Implementation details

The function `astJsonGen` performs a straightforward procedure:

1. The current working directory is retrieved so that all paths are built
   relative to it.
2. The function expects a subdirectory containing the C sources (`c_code` by
   default).  A `FileNotFoundError` is raised if the directory cannot be found
   or if it does not contain any `.c` files.
3. A `json_out` directory is created next to the source folder if it does not
   already exist.
4. Every `.c` file is compiled using a command of the form
   ```bash
   clang -Xclang -ast-dump=json -g -fsyntax-only <file.c> > json_out/<file>.json
   ```
   The `-g` and `-fsyntax-only` flags keep the compilation lightweight.  The
   command is executed via `subprocess.run` and will raise an exception if Clang
   returns a non-zero exit code.
5. After Clang runs, the script checks that the JSON file was actually created
   and reports its path.

Because the implementation is intentionally simple, there is very little hidden
state: it only relies on the presence of Clang in the environment and on the
source directory being well formed.  Error checking ensures that missing
sources or failed compilations are surfaced immediately.

## Role within the compilation pipeline

`astJsonGen.py` is the very first step in the end-to-end process.  Its sole
responsibility is to translate human written C examples into machine readable
JSON so that the rest of the toolchain can operate purely on structured data.
Once the JSON files are produced, they feed into `pipeline.py` which
1) parses the JSON into the lightweight dataclass representation defined in
`c_ast.py`, 2) lowers that representation to classical MLIR with
`mlir_generator.py`, 3) translates the MLIR into the custom quantum dialect via
`quantum_translate.py`, and finally 4) optionally builds Qiskit circuits from
the quantum dialect with `circuit_pipeline.py`.

In summary, `astJsonGen.py` provides the input artefacts on which every other
stage depends.

## Supported C subset

The broader project only handles a restricted subset of the C language.  The
current features understood by the parser (`c_ast.py`) and the MLIR lowering are
summarised below:

- **Integer types** only (`int`), with literals represented by
  `IntegerLiteral` nodes.
- **Variable declarations** with optional integer initialisers.
- **Assignments** to previously declared variables.
- **Arithmetic binary operators**: `+`, `-`, `*`, and `/`.
- **Comparison operators**: `==`, `!=`, `<`, `<=`, `>`, `>=`.
- **Logical operators** in conditions: `&&` and `||`.
- **Unary operators** such as negation (`-x`), logical not (`!x`), and bitwise
  not (`~x`).
- **Control flow**: `if`/`else` statements and `for` loops with simple
  initialiser, condition, and increment expressions.
- **Return statements** from functions.

These constructs map to dataclasses in `c_ast.py` and to a small set of MLIR
operations in `mlir_generator.py` and `dialect_ops.py`.  No pointers,
structures, arrays, or floating point types are supported.  Loops are unrolled
explicitly in the LLVM generation step when needed.

The JSON ASTs produced by `astJsonGen.py` therefore encode only this subset,
which keeps the rest of the toolchain manageable while experimenting with the
quantum dialect translation.