# QuantumC

**QuantumC** is a modular, high-level synthesis framework that compiles classical C programs into quantum circuits. It leverages structured intermediate representations (IRs) inspired by MLIR to ensure modularity, semantic correctness, and compatibility with the fundamental constraints of quantum computing (e.g., unitarity, reversibility, no-cloning).

Instead of programming directly in quantum assembly, QuantumC allows developers to write familiar C-style code and generate executable quantum circuits‚Äîready for simulation, benchmarking, or deployment on Qiskit-compatible hardware.

---

## Why QuantumC?

Modern quantum computing demands **resource-aware**, **modular**, and **reversible** circuits. Writing these manually is error-prone and impractical at scale.

QuantumC introduces:

- **High-level synthesis from C**, enabling broader access to quantum programming.
- **Intermediate Representations (IRs)** that support optimizations, inspection, and rewrites.
- **Quantum-aware lowering** that respects quantum constraints at every stage.
- **Integration with Qiskit**, producing standard OpenQASM output ready for simulation or transpilation.

QuantumC enables a self-contained, quantum-native execution model‚Äîwithout hybrid offloading of classical logic.

---

## Architecture Overview

The compilation pipeline follows these stages:

1. **C to JSON AST**  
   Uses `clang -ast-dump=json` to parse C source code.

2. **AST to Dataclasses**  
   The AST is normalized into structured Python dataclasses for clean semantic traversal.

3. **Dataclasses to Classical MLIR**  
   Lowered into a classical IR using SSA form (via xDSL), which supports control flow and typed arithmetic.

4. **Classical MLIR to Quantum IR**  
   Translated into a custom dialect encoding quantum semantics, respecting unitarity and linearity.

5. **Quantum IR to QASM**  
   Final circuits are generated using Qiskit in Clifford+T gate form.

Each stage emits intermediate artifacts for inspection and debugging.

---

## Requirements

- Python 3.10+
- Clang with `-ast-dump=json` support
- [xDSL](https://github.com/xdslproject/xdsl)
- [Qiskit](https://qiskit.org/)

Install dependencies:

```bash
python -m venv .venv
source .venv/bin/activate
pip install xdsl qiskit
```

---

## ‚öôÔ∏è How to Run

You can run the entire compilation pipeline using:

```bash
python pipeline.py                      # Compile default example (c_code/try.c)
python pipeline.py path/to/file.c       # Compile custom C file
```

Optional flags:

| Flag         | Description                                                       |
|--------------|-------------------------------------------------------------------|
| `--bits N`   | Set the number of bits per quantum integer (default: 16)          |
| `--run`      | Simulate the circuit after generation using Qiskit                |
| `--verbose`  | Print detailed debug information                                  |
| `--pretty`   | Pretty-print reconstructed C code before lowering                 |
| `--time`     | Report full compilation and simulation time                       |

Example:

```bash
python pipeline.py c_code/example.c --bits 8 --run --verbose --time
```

---

## Output Structure

The following files are generated:

| File/Dir                     | Description                                         |
|-----------------------------|-----------------------------------------------------|
| `json_out/<file>.json`      | AST generated by Clang                             |
| `mlir_out/<file>_classical.mlir` | Classical MLIR in SSA form                        |
| `quantum_mlir_out/<file>_quantum.mlir` | Quantum-aware IR (QMLIR)                    |
| `output/<file>.qasm`        | OpenQASM file emitted via Qiskit                   |

---

## Supported Features

### Language Constructs

- Scalar signed integers with configurable bitwidth (default: 16)
- Arithmetic: `+`, `-`, `*`, `/` (QFT-based, ancilla-efficient)
- Logical: `&&`, `||`, `!`
- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`
- Unary: `+`, `-`, `~`, `++`, `--` (prefix/postfix)
- Control flow: `if`, `else`, `else if`, `for`
- `return` statements

### Compilation Techniques

- Static unrolling of loops
- Quantum-controlled conditionals
- QFT-based arithmetic for ancilla minimization
- Quantum division (restoring method)
- Controlled operations with entanglement-aware design
- Compliance with unitarity, no-cloning, no-deletion

---

## Benchmarks

We evaluated the pipeline using 10 representative C benchmarks. Example:

```c
int main() {
  int acc = 1;
  for (int i = 0; i < 6; i++) {
    acc = acc * 3;
  }
  return acc;
}
```

### Compilation Time vs. Bitwidth

| Bitwidth | Time (s) |
|----------|----------|
| 4        | 0.50     |
| 8        | 1.75     |
| 16       | 10.02    |
| 32       | 92.73    |

### Quantum Complexity (16-bit registers)

| Program                          | Qubits | Gates | CX   | T    |
|----------------------------------|--------|-------|------|------|
| looped_multiplication.c         | 1037   | 43497 | 11268| 378  |
| unary_operators.c               | 64     | 1583  | 121  | 0    |
| loop_with_compound_body.c       | 1037   | 57136 | 17338| 378  |
| nested_if_else.c                | 74     | 1178  | 19   | 0    |

---

## üìÅ Repository Structure

| Folder                         | Purpose                                 |
|--------------------------------|-----------------------------------------|
| `c_code/`                      | C benchmark programs                    |
| `step1_c_to_ast/`              | AST generation with Clang               |
| `step2_ast_to_dataclasses/`    | AST parsing to Python dataclasses       |
| `step3_dataclasses_to_mlir/`   | SSA-based classical MLIR generation     |
| `step4_mlir_to_quantum_mlir/`  | Quantum-aware IR lowering               |
| `step5_quantum_mlir_to_qasm/`  | QASM generation via Qiskit              |
| `output/`                      | Emitted QASM files                      |

---

## üß≠ Future Developments

- üß¨ QASM to IR lifting for debugging and rewriting
- üîÑ Cross-dialect conversion with QIRO, xDSL, etc.
- üß† Intermediate IR optimizations (DCE, folding, etc.)
- üîß Hardware-aware lowering strategies
- üí° Integration with Verilog/SystemC frontends

---

## üìö References

The full technical report will be available in the next few days.. :)

---

## üì∏ Acknowledgments

Quantum circuit diagrams are generated with [Qiskit](https://qiskit.org/). We thank the xDSL and Qiskit communities for their tools and documentation.

## Contributions
- Leonardo Ignazio Pagliochini - [GitHub](https://github.com/leonardopagliochini)
- Francesco Rosnati - [GitHub](https://github.com/RosNaviGator)
